## Day 1 and Day 2

I am starting Clojure through the ground up. Since I am already experienced with Clojure, I am going through this material to revise basics concept, so I will be breezing through this and not spending much time on this material. I will be making notes of things that I feel are new to me or which needs to be brushed upon.

Also, I want to do the entire exercices in emacs. I already had it installed and config put in. I needed little hand holding, so I played around emacs for a little bit, changed theme and all :)
I used [Absolute Beginner's Guide to Emacs](http://www.jesshamrick.com/2012/09/10/absolute-beginners-guide-to-emacs/) for brushing up my emacs skill.
The config and shortcuts that I use can be found here: https://gitlab.com/p4v4n/emacs.d.quintype

## This notes covers following chapters:
- [Welcome](https://aphyr.com/posts/301-clojure-from-the-ground-up-welcome)
- [Clojure from the ground up: basic types](https://aphyr.com/posts/302-clojure-from-the-ground-up-basic-types)
- [Clojure from the ground up: functions](https://aphyr.com/posts/303-clojure-from-the-ground-up-functions)

### Metalanguages
This word is interesting and even though I have come across it previously many times I hadn't gone and looked into it. For someone who was fascinated by the ideas of macros I realised that as metalanguage is defined as a *language used to describe other language* I have been experiencing the metalanguage all the while without actually knowing that it was termed that way.

### First-class language constructs
https://stackoverflow.com/questions/646794/what-is-a-first-class-programming-construct/646862#646862
For example in languages like C you cannot pass a function as an argument of another function, but you can do that in Clojure or any other language that supports first class language construct. 

### Concurrency
- To be explored later on

Clojure emphasizes:
- Safety in its type systems
- Approach to parallelism

Clojure:
- makes it easier to write correct multithreaded programs.
- offers repl and dynamic type system - types enforced when program in run instead when program in first read by the computer- well suited for manipulating complex data structures. (TODO: explore more on this)
- compiled language, hence slower to start, not suited for high performance numeric operations.
- Has *strong* type system - operations on improper types are not allowed


## Brush up
- false and nil - only negative values
- double - default for numbers in clojure
- Symbols - references to other values
- Function represent unrealized computation
- Functions exist to defer evaluation
- let: associates names with values in a particular expression
- var: allow for mutale bindings which apply universally whose definitions can change over time. 